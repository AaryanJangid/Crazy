<!DOCTYPE html>
<html>
<head>
    <title>Hybrid Particle System</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/0.160.0/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <style>
        body { margin: 0; overflow: hidden; background: #000; color: #00ffcc; font-family: 'Courier New', monospace; touch-action: none; }
        #ui { position: absolute; top: 10px; left: 10px; z-index: 10; pointer-events: none; background: rgba(0,0,0,0.7); padding: 15px; border-radius: 10px; border: 1px solid #00ffcc; }
        .key { color: #ff00ff; font-weight: bold; border: 1px solid #ff00ff; padding: 0 5px; }
        video { display: none; }
        #cam-status { position: absolute; bottom: 10px; right: 10px; font-size: 12px; color: #555; }
    </style>
</head>
<body>
    <div id="ui">
        <h3>HYBRID CONTROLS:</h3>
        <li><span class="key">G</span>-Galaxy | <span class="key">C</span>-Cosmos</li>
        <li><span class="key">S</span>-Sphere | <span class="key">H</span>-Heart</li>
        <li><span class="key">Space</span>-BURST | <span class="key">Double Tap</span>-Next</li>
        <br>
        <li><b>Touch:</b> Drag to Move/Rotate</li>
        <li><b>Camera:</b> Move Hand to Control</li>
    </div>
    <div id="cam-status">Camera: Initializing/Off</div>
    <video id="input_video"></video>

    <script>
        // --- THREE.JS SETUP ---
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
        camera.position.z = 20;
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // --- SHADERS ---
        const _VS = `attribute float aSize; varying vec3 vColor; void main() { vColor = color; vec4 mvPosition = modelViewMatrix * vec4(position, 1.0); gl_PointSize = aSize * (750.0 / -mvPosition.z); gl_Position = projectionMatrix * mvPosition; }`;
        const _FS = `varying vec3 vColor; void main() { if (distance(gl_PointCoord, vec2(0.5)) > 0.5) discard; gl_FragColor = vec4(vColor, 1.0); }`;

        // --- PARTICLES ---
        const count = 15000;
        const geo = new THREE.BufferGeometry();
        const positions = new Float32Array(count * 3);
        const targetPos = new Float32Array(count * 3);
        const colors = new Float32Array(count * 3);
        const sizes = new Float32Array(count);

        for (let i = 0; i < count; i++) {
            sizes[i] = Math.random() * 0.12 + 0.04;
            positions[i*3] = (Math.random()-0.5)*50;
            positions[i*3+1] = (Math.random()-0.5)*50;
            positions[i*3+2] = (Math.random()-0.5)*50;
        }

        geo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        geo.setAttribute('color', new THREE.BufferAttribute(colors, 3));
        geo.setAttribute('aSize', new THREE.BufferAttribute(sizes, 1));

        const mat = new THREE.ShaderMaterial({ vertexShader: _VS, fragmentShader: _FS, transparent: true, blending: THREE.AdditiveBlending, vertexColors: true });
        const points = new THREE.Points(geo, mat);
        scene.add(points);

        let currentMode = 'sphere';
        const modes = ['sphere', 'galaxy', 'cosmos', 'heart'];

        function updateTargets(type) {
            currentMode = type;
            const color = new THREE.Color();
            for (let i = 0; i < count; i++) {
                const i3 = i * 3;
                if (type === 'sphere') {
                    const u = Math.random(), v = Math.random();
                    const theta = 2 * Math.PI * u, phi = Math.acos(2 * v - 1);
                    targetPos[i3] = 7 * Math.sin(phi) * Math.cos(theta);
                    targetPos[i3+1] = 7 * Math.sin(phi) * Math.sin(theta);
                    targetPos[i3+2] = 7 * Math.cos(phi);
                    color.setHSL(0.6, 0.8, 0.5);
                } else if (type === 'galaxy') {
                    const angle = Math.random() * Math.PI * 2;
                    const r = Math.pow(Math.random(), 0.5) * 14;
                    targetPos[i3] = Math.cos(angle + r*0.8) * r;
                    targetPos[i3+1] = Math.sin(angle + r*0.8) * r;
                    targetPos[i3+2] = (Math.random() - 0.5) * 2;
                    color.setHSL(0.8, 0.9, 0.6);
                } else if (type === 'cosmos') {
                    targetPos[i3] = (Math.random()-0.5)*50; targetPos[i3+1] = (Math.random()-0.5)*50; targetPos[i3+2] = (Math.random()-0.5)*50;
                    color.setHSL(Math.random(), 0.8, 0.7);
                } else if (type === 'heart') {
                    const t = Math.random() * Math.PI * 2;
                    targetPos[i3] = (16 * Math.pow(Math.sin(t), 3)) * 0.45;
                    targetPos[i3+1] = (13*Math.cos(t) - 5*Math.cos(2*t) - 2*Math.cos(3*t) - Math.cos(4*t)) * 0.45;
                    targetPos[i3+2] = (Math.random()-0.5)*2;
                    color.setHSL(0.0, 1.0, 0.5);
                }
                colors[i3] = color.r; colors[i3+1] = color.g; colors[i3+2] = color.b;
            }
            geo.attributes.color.needsUpdate = true;
        }
        updateTargets('sphere');

        // --- CONTROLS LOGIC ---
        // 1. Mouse/Touch
        window.addEventListener('pointermove', (e) => {
            const x = (e.clientX / window.innerWidth - 0.5) * 30;
            const y = -(e.clientY / window.innerHeight - 0.5) * 25;
            points.position.lerp(new THREE.Vector3(x, y, 0), 0.1);
            points.rotation.y = x * 0.1;
            points.rotation.x = -y * 0.1;
        });

        // 2. Keyboard
        window.addEventListener('keydown', (e) => {
            const k = e.key.toLowerCase();
            if (['g','c','s','h'].includes(k)) {
                const map = {g:'galaxy', c:'cosmos', s:'sphere', h:'heart'};
                updateTargets(map[k]);
            }
            if (k === ' ') {
                for(let i=0; i<count*3; i++) targetPos[i] *= 5.0;
                setTimeout(() => updateTargets(currentMode), 400);
            }
        });

        // 3. Double Tap (Touch Screens)
        let lastTap = 0;
        window.addEventListener('touchstart', (e) => {
            const now = Date.now();
            if (now - lastTap < 300) {
                const next = modes[(modes.indexOf(currentMode) + 1) % modes.length];
                updateTargets(next);
            }
            lastTap = now;
        });

        // --- CAMERA (MediaPipe) ---
        const videoElement = document.getElementById('input_video');
        const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
        hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });
        
        hands.onResults((res) => {
            if (res.multiHandLandmarks && res.multiHandLandmarks.length > 0) {
                document.getElementById('cam-status').innerText = "Camera: Hand Active";
                const hand = res.multiHandLandmarks[0][9]; // Middle finger base
                const x = (hand.x - 0.5) * -35;
                const y = (hand.y - 0.5) * -25;
                points.position.lerp(new THREE.Vector3(x, y, 0), 0.2);
                
                // Palm Burst
                const tip = res.multiHandLandmarks[0][12].y;
                const wrist = res.multiHandLandmarks[0][0].y;
                if (Math.abs(tip - wrist) > 0.4) { // Open Palm
                    for(let i=0; i<count*3; i++) targetPos[i] *= 1.05;
                    setTimeout(() => updateTargets(currentMode), 100);
                }
            }
        });

        const cam = new Camera(videoElement, {
            onFrame: async () => { await hands.send({image: videoElement}); },
            width: 640, height: 480
        });
        cam.start().catch(() => { document.getElementById('cam-status').innerText = "Camera: Not Found/Blocked"; });

        // --- ANIMATE ---
        function animate() {
            requestAnimationFrame(animate);
            const p = geo.attributes.position;
            for (let i = 0; i < count * 3; i++) {
                p.array[i] += (targetPos[i] - p.array[i]) * 0.1;
            }
            p.needsUpdate = true;
            renderer.render(scene, camera);
        }
        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
